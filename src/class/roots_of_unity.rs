use crate::embeddings::CEmbeddings;
use num::{BigInt, Zero};
use number_theory_linear::cholesky::Cholesky;
use number_theory_linear::lll;

pub fn find_muk(emb: &CEmbeddings) -> usize {
    find_muk_with_margin(emb, 0.0625)
}
#[allow(clippy::many_single_char_names, clippy::needless_range_loop)]
fn find_muk_with_margin(emb: &CEmbeddings, margin: f64) -> usize {
    let r = emb.real();
    let s = emb.complex();
    let n = r + 2 * s;
    let mut basis = vec![vec![0.0; n]; n];
    for i in 0..r {
        for j in 0..n {
            let val = emb.get(i, j);
            basis[j][i] = val.re;
        }
    }
    let sqrt2 = 2.0f64.sqrt();
    for i in 0..s {
        for j in 0..n {
            let val = emb.get(r + i, j);
            basis[j][r + 2 * i] = val.re * sqrt2;
            basis[j][r + 2 * i + 1] = val.im * sqrt2;
        }
    }
    let (lll, h) = lll(&basis);
    let mut q = vec![vec![0.0; n]; n];
    for i in 0..n {
        for j in 0..n {
            for k in 0..n {
                q[i][j] += lll[i][k] * lll[j][k];
            }
        }
    }
    let cho = Cholesky::find(&q);
    let vecs = cho.find_short_vectors(n as f64 + margin);
    let mut units = 0;
    for (_sqdist, num) in vecs {
        let num: Vec<BigInt> = num.into_iter().map(BigInt::from).collect();
        let mut num_conv = vec![BigInt::zero(); n];
        for i in 0..n {
            for j in 0..n {
                num_conv[j] += &num[i] * &h[i][j];
            }
        }
        let mut ok = true;
        for i in 0..r + s {
            let val = emb.compute(i, &num_conv);
            let sqnorm = val.norm_sqr();
            if (sqnorm - 1.0).abs() >= 1e-9 {
                ok = false;
            }
        }
        if ok {
            units += 1;
        }
    }
    2 * units
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::algebraic::Algebraic;
    use crate::integral_basis::find_integral_basis;
    use crate::numerical_roots::find_roots_reim;
    use crate::polynomial::Polynomial;
    use num::ToPrimitive;

    fn find_muk_from_polynomial(poly_vec: &[BigInt]) -> usize {
        let poly = Polynomial::from_raw(poly_vec.to_vec());
        let poly_complex =
            Polynomial::from_raw(poly_vec.iter().map(|b| b.to_f64().unwrap()).collect());
        let theta = Algebraic::new(poly);
        let o = find_integral_basis(&theta);

        // Find embeddings and roots of unity
        let (roots_re, roots_im) = find_roots_reim(poly_complex);
        let basis = CEmbeddings::new(&roots_re, &roots_im, &o);
        find_muk_with_margin(&basis, 5.0)
    }

    #[test]
    fn find_muk_works_for_gaussian_ints() {
        // X^2 + 1. The ring of integers of Q(i) is Z[i].
        let poly_vec: Vec<BigInt> = vec![1.into(), 0.into(), 1.into()];
        let muk = find_muk_from_polynomial(&poly_vec);
        // It has four roots of unity, generated by i.
        assert_eq!(muk, 4);
    }

    #[test]
    fn find_muk_works_for_eisenstein_ints() {
        // X^2 + 3. The ring of integers of Q(sqrt(-3)) is Z[omega].
        let poly_vec: Vec<BigInt> = vec![3.into(), 0.into(), 1.into()];
        let muk = find_muk_from_polynomial(&poly_vec);
        // It has six roots of unity, generated by 1+omega.
        assert_eq!(muk, 6);
    }

    #[test]
    fn find_muk_works_for_qz8() {
        // The minimal polynomial of sqrt(2)+i. The ring of integers of Q(sqrt(2)+i)=Q(zeta_8) is Z[zeta_8].
        let poly_vec: Vec<BigInt> = vec![9.into(), 0.into(), (-2).into(), 0.into(), 1.into()];
        let muk = find_muk_from_polynomial(&poly_vec);
        // It has eight roots of unity, generated by zeta_8.
        assert_eq!(muk, 8);
    }

    #[test]
    fn find_muk_works_extra() {
        // The minimal polynomial of cbrt(2)+sqrt(-3). The ring of integers contains Z[omega].
        let poly_vec: Vec<BigInt> = vec![
            31.into(),
            36.into(),
            27.into(),
            (-4).into(),
            9.into(),
            0.into(),
            1.into(),
        ];
        let muk = find_muk_from_polynomial(&poly_vec);
        // It has six roots of unity, generated by 1+omega.
        assert_eq!(muk, 6);
    }

    #[test]
    fn find_muk_works_for_cubic() {
        // The minimal polynomial of cbrt(7).
        let poly_vec: Vec<BigInt> = vec![(-7).into(), 0.into(), 0.into(), 1.into()];
        let muk = find_muk_from_polynomial(&poly_vec);
        // It has two roots of unity, generated by -1.
        assert_eq!(muk, 2);
    }
}
